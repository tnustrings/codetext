begin a file named foo.py.

``//foo.py: #py
print("ooh, baby you're a fool to py") 
if bar {
  ``bar``
}
``

the two ticks `` open and close a code chunk.

the two slashes // mark the following path to begin with a file name,
foo.py.

when we open a chunk for the first time, its path is followed by a
colon, like here.

the #py signals syntax highlighting, you can leave it out.

our chunk //foo.py references a child-chunk, ``bar``. we put code into
bar by opening a second code chunk, /bar.

``/bar: #py
   print("my bar")
   ``baz``
   ``boz``
``

bar in turn references two child chunks, ``baz`` and ``boz``. to put
code into baz, we could use the full path /bar/baz, or the relative
path starting from bar, ./baz.

``./baz: #py
   my = "baz code"
``

if you leave out the path you stay in the same chunk.

`` #py
   print("still in baz")
``

if we would like to change to baz's sibling chunk boz now, we could say
../boz, /bar/boz, //foo.py/bar/boz or /*/boz, if boz's name is unique
in foo.

``../boz: #py
   print("in boz")
``

if there's a loop or so, and we'd like the next unnamed chunk to be
inside of the loop we can specify where it should be put with ``.``:

`` #py
   for i = 0; i < n; i++ {
      ``.``
   }
``

now the following unnamed chunk won't be appended to the end of the
previous chunk but instead where the ``.`` is.

`` #py
   print("inside the loop")
``

you need to exit this 'ghost'-chunk via ../ to append code after the
loop again:

``../ #py
   print("after the loop")
``

we open a second file, named zoo.py.

``//zoo.py: #py
  welcome to the zoo
  ``dolphins``
``

chunk paths assume to start at the last opened file (unless the
filename is explicitly given). our last opened file is zoo.py now, so
the path /dolphins adds code to zoo.py.

``/dolphins: #py
  print("are there dolphins in the zoo?")
``

you can switch back to a chunk in foo.py like this:

``//foo.py/bar #py
  print("hello bar again")
``

now our file is assumed to be foo.py again.

``
  print("still in foo.py")
``
